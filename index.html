<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Portfolio - Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }
        #coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Controls:</strong><br>
        W - Move forward<br>
        S - Move backward<br>
        A - Turn left<br>
        D - Turn right<br>
        SPACE - Jump<br>
        <br>
        Walk around the planet!
    </div>

    <div id="coordinates">
        Position: (0, 0, 0)
    </div>
    
    <div id="intro-screen">
        <div id="intro-content">
            <h1>Max's World</h1>
            <p id="enter-prompt">Press ENTER to begin</p>
        </div>
    </div>
    
    <style>
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }
        
        #intro-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        #intro-content {
            text-align: center;
            color: white;
        }
        
        #intro-content h1 {
            font-size: 4em;
            margin-bottom: 30px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        
        #enter-prompt {
            font-size: 1.5em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.Fog(0x0a0a1a, 20, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x808080, 2.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(10, 10, 10);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -20;
        sunLight.shadow.camera.right = 20;
        sunLight.shadow.camera.top = 20;
        sunLight.shadow.camera.bottom = -20;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 100;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.bias = -0.001;
        sunLight.shadow.normalBias = 0.02;

        // Planet
        const planetRadius = 16;
        
        const planetGroup = new THREE.Group();
        planetGroup.add(sunLight);
        scene.add(planetGroup);

        // Load the Blender world model
        const planetLoader = new GLTFLoader();
        planetLoader.load('world-only.glb', function(gltf) {
            const planet = gltf.scene;
            
            planet.traverse((child) => {
                if (child.isMesh) {
                    const isGround = child.name.toLowerCase().includes('ground');
                    child.castShadow = !isGround;
                    child.receiveShadow = true;
                    console.log(`Mesh: ${child.name}, castShadow: ${!isGround}, receiveShadow: true`);
                }
            });
            
            planetGroup.add(planet);
            console.log('Blender world model loaded successfully');
        }, undefined, function(error) {
            console.error('Error loading world model:', error);
        });

        // Character setup
        const characterGroup = new THREE.Group();
        scene.add(characterGroup);

        // Animation mixer and actions
        let mixer = null;
        let walkAction = null;
        let idleAction = null;
        let characterModel = null;
        let characterLoaded = false;

        // Animation state
        const animationState = {
            isWalking: false
        };

        // Load penguin character model
        const characterLoader = new GLTFLoader();
        characterLoader.load('manchot_the_penguin.glb', 
            function(gltf) {
                console.log('Penguin character loaded successfully!');
                characterModel = gltf.scene;
                
                // Scale the penguin to appropriate size
                characterModel.scale.set(0.075, 0.075, 0.075);
                
                // Enable shadows
                characterModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                characterGroup.add(characterModel);
                
                // Setup animation mixer
                if (gltf.animations && gltf.animations.length > 0) {
                    console.log('Found animations:', gltf.animations.map(a => a.name));
                    
                    mixer = new THREE.AnimationMixer(characterModel);
                    
                    // Try to find walk animation
                    const walkAnim = gltf.animations.find(a => 
                        a.name.toLowerCase().includes('walk') || 
                        a.name.toLowerCase().includes('run') ||
                        a.name.toLowerCase().includes('waddle')
                    ) || gltf.animations[0]; // Fallback to first animation
                    
                    // Try to find idle animation
                    const idleAnim = gltf.animations.find(a => 
                        a.name.toLowerCase().includes('idle') || 
                        a.name.toLowerCase().includes('standing')
                    );
                    
                    if (walkAnim) {
                        walkAction = mixer.clipAction(walkAnim);
                        walkAction.setEffectiveTimeScale(1.2); // Speed up animation
                        console.log('Walk animation set:', walkAnim.name);
                    }
                    
                    if (idleAnim) {
                        idleAction = mixer.clipAction(idleAnim);
                        idleAction.play();
                        console.log('Idle animation set:', idleAnim.name);
                    } else if (walkAction) {
                        // If no idle, just stop walk animation when not moving
                        console.log('No idle animation found, using walk animation only');
                    }
                } else {
                    console.warn('No animations found in penguin model');
                }
                
                characterLoaded = true;
                console.log('Penguin character setup complete');
            }, 
            function(progress) {
                console.log('Loading penguin:', (progress.loaded / progress.total * 100).toFixed(2) + '%');
            },
            function(error) {
                console.error('Error loading penguin model:', error);
            }
        );

        // Position character at spawn height
        const characterHeight = 0.075;
        const spawnHeight = 13; // Spawn higher to ensure proper ground detection
        characterGroup.position.set(0, spawnHeight, 0);

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
        const starsVertices = [];
        for (let i = 0; i < 1000; i++) {
            const x = (Math.random() - 0.5) * 100;
            const y = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        planetGroup.add(stars);

        // Atmosphere
        const atmosphereGeometry = new THREE.SphereGeometry(25, 32, 32);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                sunDirection: { value: new THREE.Vector3(1, 1, 1).normalize() },
                dayColor: { value: new THREE.Color(0x87CEEB) },
                nightColor: { value: new THREE.Color(0x000000) },
                horizonColor: { value: new THREE.Color(0xFFB347) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 sunDirection;
                uniform vec3 dayColor;
                uniform vec3 nightColor;
                uniform vec3 horizonColor;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vec3 normal = normalize(vPosition);
                    float sunAlignment = dot(normal, sunDirection);
                    float dayStrength = smoothstep(-0.3, 0.3, sunAlignment);
                    float horizonGlow = 1.0 - abs(sunAlignment);
                    horizonGlow = pow(horizonGlow, 3.0) * dayStrength;
                    vec3 skyColor = mix(nightColor, dayColor, dayStrength);
                    skyColor = mix(skyColor, horizonColor, horizonGlow * 0.5);
                    float alpha = dayStrength * 0.9 + 0.1;
                    gl_FragColor = vec4(skyColor, alpha);
                }
            `,
            side: THREE.BackSide,
            transparent: true,
            depthWrite: false
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Sun
        const sunDistance = 50;
        const sunRadius = 5;
        const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffdd,
            fog: false
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(10, 10, 10).normalize().multiplyScalar(sunDistance);
        planetGroup.add(sun);

        const sunGlowGeometry = new THREE.SphereGeometry(sunRadius * 1.6, 32, 32);
        const sunGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffdd99,
            transparent: true,
            opacity: 0.5,
            fog: false
        });
        const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
        sunGlow.position.copy(sun.position);
        planetGroup.add(sunGlow);

        const sunGlow2Geometry = new THREE.SphereGeometry(sunRadius * 2.2, 32, 32);
        const sunGlow2Material = new THREE.MeshBasicMaterial({
            color: 0xffbb66,
            transparent: true,
            opacity: 0.25,
            fog: false
        });
        const sunGlow2 = new THREE.Mesh(sunGlow2Geometry, sunGlow2Material);
        sunGlow2.position.copy(sun.position);
        planetGroup.add(sunGlow2);

        // Moon
        const moonDistance = 40;
        const moonRadius = 3;
        const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
        const moonMaterial = new THREE.MeshBasicMaterial({
            color: 0xeeeeff,
            fog: false
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        const sunDirection = new THREE.Vector3(10, 10, 10).normalize();
        moon.position.copy(sunDirection).multiplyScalar(-moonDistance);
        planetGroup.add(moon);

        const moonGlowGeometry = new THREE.SphereGeometry(moonRadius * 1.5, 32, 32);
        const moonGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xccddff,
            transparent: true,
            opacity: 0.4,
            fog: false
        });
        const moonGlow = new THREE.Mesh(moonGlowGeometry, moonGlowMaterial);
        moonGlow.position.copy(moon.position);
        planetGroup.add(moonGlow);

        const moonLight = new THREE.PointLight(0xaabbdd, 0.8, 100);
        moonLight.position.copy(moon.position);
        planetGroup.add(moonLight);

        const moonDirectionalLight = new THREE.DirectionalLight(0x8899cc, 0.25);
        moonDirectionalLight.position.copy(moon.position);
        planetGroup.add(moonDirectionalLight);

        // Cloud system
        const cloudGroup = new THREE.Group();
        planetGroup.add(cloudGroup);

        const cloudAnimations = [];
        const rainClouds = [];

        // Camera setup
        const cameraDistance = 1.5;
        const cameraHeight = 1.2; // Lifted higher

        camera.position.set(0, spawnHeight + cameraHeight, -cameraDistance);
        camera.lookAt(0, spawnHeight, 0);

        // Input handling
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false
        };

        // Physics
        const physics = {
            velocity: new THREE.Vector3(0, 0, 0),
            gravity: 20.0,
            isGrounded: false,
            jumpForce: 5.0,
            characterRadius: 0.1
        };

        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);

        let introActive = true;

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (e.key === 'Enter' && introActive) {
                introActive = false;
                document.getElementById('intro-screen').classList.add('fade-out');
                setTimeout(() => {
                    document.getElementById('intro-screen').style.display = 'none';
                }, 1000);
                return;
            }

            if (key in keys && !introActive) {
                keys[key] = true;
            }

            if (e.code === 'Space' && !introActive && physics.isGrounded) {
                physics.velocity.y = physics.jumpForce;
                physics.isGrounded = false;
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (e.code === 'Space') keys.space = false;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        const moveSpeed = 0.0008; // Slowed down character movement
        const turnSpeed = 0.006; // Turn speed slightly increased
        let characterRotation = 0;
        const dayNightSpeed = 0.05; // Increased for testing
        let dayNightAngle = 0;
        
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update animation mixer
            if (mixer && characterLoaded) {
                mixer.update(deltaTime);

                // Handle walk/idle transitions
                if (walkAction && idleAction) {
                    if (animationState.isWalking) {
                        // Switch to walk
                        if (idleAction.isRunning() && !walkAction.isRunning()) {
                            idleAction.fadeOut(0.2);
                            walkAction.reset().fadeIn(0.2).play();
                        }
                    } else {
                        // Switch to idle
                        if (walkAction.isRunning() && !idleAction.isRunning()) {
                            walkAction.fadeOut(0.2);
                            idleAction.reset().fadeIn(0.2).play();
                        }
                    }
                } else if (walkAction) {
                    // Only walk animation available
                    if (animationState.isWalking) {
                        if (!walkAction.isRunning()) {
                            walkAction.play();
                        }
                    } else {
                        if (walkAction.isRunning()) {
                            walkAction.stop();
                        }
                    }
                }
            }

            // Day/night cycle
            dayNightAngle += dayNightSpeed * deltaTime;

            const sunRotationAxis = new THREE.Vector3(1, 0, 0);
            const sunBasePosition = new THREE.Vector3(10, 10, 10).normalize().multiplyScalar(sunDistance);
            sun.position.copy(sunBasePosition);
            sun.position.applyAxisAngle(sunRotationAxis, dayNightAngle);
            sunGlow.position.copy(sun.position);
            sunGlow2.position.copy(sun.position);
            sunLight.position.copy(sun.position);

            sunLight.target.position.set(0, 0, 0);
            sunLight.target.updateMatrixWorld();

            moon.position.copy(sun.position).multiplyScalar(-1);
            moonGlow.position.copy(moon.position);
            moonLight.position.copy(moon.position);
            moonDirectionalLight.position.copy(moon.position);

            moonDirectionalLight.target.position.set(0, 0, 0);
            moonDirectionalLight.target.updateMatrixWorld();

            const sunWorldPos = new THREE.Vector3();
            sun.getWorldPosition(sunWorldPos);
            const sunDir = sunWorldPos.normalize();
            atmosphereMaterial.uniforms.sunDirection.value.copy(sunDir);

            // Gameplay
            if (!introActive) {
                physics.velocity.y -= physics.gravity * deltaTime;
                const newY = characterGroup.position.y + physics.velocity.y * deltaTime;

                const rayOrigin = new THREE.Vector3(
                    characterGroup.position.x,
                    characterGroup.position.y, // Start from character center
                    characterGroup.position.z
                );

                raycaster.set(rayOrigin, downVector);
                raycaster.far = 50;

                const collisionMeshes = [];
                planetGroup.traverse((child) => {
                    if (child.isMesh) {
                        collisionMeshes.push(child);
                    }
                });

                const intersects = raycaster.intersectObjects(collisionMeshes, false);

                if (intersects.length > 0) {
                    const groundY = intersects[0].point.y;
                    // Offset character slightly above ground to prevent clipping
                    const groundOffset = 0.028;
                    const targetY = groundY + groundOffset;
                    const distanceToGround = characterGroup.position.y - groundY;
                    const groundTolerance = 0.1;

                    if (distanceToGround <= groundTolerance && physics.velocity.y <= 0) {
                        characterGroup.position.y = targetY;
                        physics.velocity.y = 0;
                        physics.isGrounded = true;
                    } else {
                        characterGroup.position.y = newY;
                        physics.isGrounded = false;
                    }
                } else {
                    characterGroup.position.y = newY;
                    physics.isGrounded = false;
                }

                // Update coordinates display
                document.getElementById('coordinates').textContent =
                    `Position: (${characterGroup.position.x.toFixed(2)}, ${characterGroup.position.y.toFixed(2)}, ${characterGroup.position.z.toFixed(2)})`;

                characterGroup.position.x = 0;
                characterGroup.position.z = 0;

                if (keys.a) {
                    characterRotation += turnSpeed;
                }
                if (keys.d) {
                    characterRotation -= turnSpeed;
                }

                characterGroup.rotation.y = characterRotation;

                if (keys.w || keys.s) {
                    animationState.isWalking = true;

                    const direction = keys.w ? -1 : 1;

                    const forwardWorld = new THREE.Vector3(
                        Math.sin(characterRotation),
                        0,
                        Math.cos(characterRotation)
                    );

                    const rotationAxis = new THREE.Vector3().crossVectors(
                        new THREE.Vector3(0, 1, 0),
                        forwardWorld
                    ).normalize();

                    const rotation = new THREE.Quaternion();
                    rotation.setFromAxisAngle(rotationAxis, direction * moveSpeed);

                    let collision = false;

                    const forwardRayOrigin = new THREE.Vector3(0, characterGroup.position.y, 0);
                    const forwardDirection = new THREE.Vector3(
                        -Math.sin(characterRotation) * direction,
                        0,
                        -Math.cos(characterRotation) * direction
                    );

                    const forwardRaycaster = new THREE.Raycaster(forwardRayOrigin, forwardDirection, 0, 0.2);
                    const forwardIntersects = forwardRaycaster.intersectObjects(collisionMeshes, false);

                    if (forwardIntersects.length > 0) {
                        const obstacleHeight = forwardIntersects[0].point.y;
                        const obstacleDistance = forwardIntersects[0].distance;
                        const stepHeight = obstacleHeight - (characterGroup.position.y - characterHeight);

                        // Block if obstacle is tall (like a wall) or close enough to prevent arm clipping
                        if (stepHeight > 0.05 || obstacleDistance < 0.15) {
                            collision = true;
                        }
                    }

                    if (!collision) {
                        planetGroup.quaternion.multiplyQuaternions(rotation, planetGroup.quaternion);
                    }
                } else {
                    animationState.isWalking = false;
                }

                // Update camera
                const cameraOffsetLocal = new THREE.Vector3(0, cameraHeight, -cameraDistance);
                const cameraOffsetWorld = cameraOffsetLocal.clone();
                cameraOffsetWorld.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterRotation);

                camera.position.copy(characterGroup.position).add(cameraOffsetWorld);

                const lookAtOffset = new THREE.Vector3(0, characterHeight, 1);
                lookAtOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterRotation);
                const lookAtPoint = characterGroup.position.clone().add(lookAtOffset);
                camera.lookAt(lookAtPoint);
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>